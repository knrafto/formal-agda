{-# OPTIONS --cubical #-}
module Math.Int where

open import Agda.Builtin.FromNat
open import Agda.Builtin.FromNeg
open import Cubical.Foundations.Equiv.HalfAdjoint using (isHAEquiv)
open import Cubical.HITs.Ints.HAEquivInt using (suc-haequiv)
open import Cubical.HITs.Ints.HAEquivInt public using (zero; suc) renaming (HAEquivInt to ℤ)
open import Math.Function
open import Math.Id
open import Math.Nat using () renaming (_+_ to _+ℕ_)
open import Math.Type

-- Just as ℕ is generated by a point (zero) and a function suc : A → A (an endomorphism),
-- ℤ is generated by a point (zero) and an equivalence suc : A ≃ A (an automorphism).

private
  -- HoTT book Lemma 4.2.5
  fiber≡ : ∀ {ℓ} {A B : Type ℓ} (f : A → B) (y : B) {x : A} {p : f x ≡ y} {x' : A} {p' : f x' ≡ y} →
          (γ : x ≡ x') → ap f γ ∙ p' ≡ p → (x , p) ≡ (x' , p')
  fiber≡ f y γ α = Σ≡ γ {!!}

  -- HoTT book Theorem 4.2.6
  haequiv→IsEquiv : ∀ {ℓ} {A B : Type ℓ} (f : A → B) → isHAEquiv f → IsEquiv f
  haequiv→IsEquiv {A = A} {B = B} f f-isHAEquiv = record { equiv-proof = fiber-IsContr }
    where
     g = isHAEquiv.g f-isHAEquiv
     η = isHAEquiv.sec f-isHAEquiv
     ε = isHAEquiv.ret f-isHAEquiv
     τ = isHAEquiv.com f-isHAEquiv

     fiber-lemma : (y : B) (x : A) (p : f x ≡ y) → (g y , ε y) ≡ (x , p)
     fiber-lemma y x p = fiber≡ f y γ α
       where
       γ : g y ≡ x
       γ = sym (ap g p) ∙ η x

       -- TODO: naturality of ε? page 176
       α : ap f γ ∙ p ≡ ε y
       α = {!!}

     fiber-IsContr : (y : B) → IsContr (fiber f y)
     fiber-IsContr y = (g y , ε y) , λ { (x , p) → fiber-lemma y x p }

suc-IsEquiv : IsEquiv suc
suc-IsEquiv = haequiv→IsEquiv suc (snd suc-haequiv)

pred : ℤ → ℤ
pred = inv suc-IsEquiv

pred-IsEquiv : IsEquiv pred
pred-IsEquiv = inv-IsEquiv suc-IsEquiv

-- is this fromℕ or toℤ?
fromℕ : ℕ → ℤ
fromℕ ℕ.zero = zero
fromℕ (ℕ.suc n) = suc (fromℕ n)

ℤ-ind : ∀ {ℓ} (P : ℤ → Type ℓ) → P zero → (P-suc : ∀ n → P n → P (suc n)) → (∀ n → IsEquiv (P-suc n)) → (n : ℤ) → P n
ℤ-ind P P-zero P-suc P-suc-IsEquiv = φ
  where
    φ : (n : ℤ) → P n
    φ zero = P-zero
    φ (suc n) = P-suc n (φ n)
    φ (ℤ.pred n) = {!!}
    φ (ℤ.suc-pred n i) = {!!}
    φ (ℤ.pred-suc n i) = {!!}
    φ (ℤ.coh n i j) = {!!}

ℤ-ind-IsProp : ∀ {ℓ} (P : ℤ → Type ℓ) → (∀ n → IsProp (P n)) → P zero → (∀ n → P n → P (suc n)) → (∀ n → P (suc n) → P n) → (n : ℤ) → P n
ℤ-ind-IsProp P P-IsProp P-zero P-suc P-pred = ℤ-ind P P-zero P-suc λ n → ⟺→IsEquiv (P-IsProp n) (P-IsProp (suc n)) (P-pred n)

ℤ-rec : ∀ {ℓ} {A : Type ℓ} (a : A) (f : A → A) → IsEquiv f → ℤ → A
ℤ-rec {A = A} a f f-IsEquiv = φ
  where
    φ : ℤ → A
    φ zero = a
    φ (suc n) = f (φ n)
    φ (ℤ.pred n) = inv f-IsEquiv (φ n)
    φ (ℤ.suc-pred n i) = rightInv f-IsEquiv (φ n) i
    φ (ℤ.pred-suc n i) = leftInv f-IsEquiv (φ n) i
    φ (ℤ.coh n i j) = comInv f-IsEquiv (φ n) i j

private
  -- TODO: characterize identity type via ℤ-rec
  code : ℤ → ℤ → Type₀
  code = {!!}

ℤ-IsSet : IsSet ℤ
ℤ-IsSet = {!!}

-- Addition
_+_ : ℤ → ℤ → ℤ
_+_ = ℤ-rec id (suc ∘_) (f∘-IsEquiv suc-IsEquiv)

-- Additive inverse
negate : ℤ → ℤ
negate = ℤ-rec zero pred pred-IsEquiv

-- Addition forms an abelian group
+-assoc : ∀ {l m n} → l + (m + n) ≡ (l + m) + n
+-assoc = {!!}

+-comm : ∀ {m n} → m + n ≡ n + m
+-comm = {!!}

zero-+ : ∀ {n} → zero + n ≡ n
zero-+ {n} = {!!}

+-zero : ∀ {n} → n + zero ≡ n
+-zero = {!!}

negate-+ : ∀ {n} → negate n + n ≡ zero
negate-+ = {!!}

+-negate : ∀ {n} → n + negate n ≡ zero
+-negate = {!!}

-- fromℕ-+ is a group homomorphism
fromℕ-+ : ∀ {m n} → fromℕ (m +ℕ n) ≡ fromℕ m + fromℕ n
fromℕ-+ = {!!}

-- Agda integer literals
instance
  Numberℤ : Number ℤ
  Numberℤ = record
    { Constraint = λ n → ⊤
    ; fromNat = λ n → fromℕ n
    }

  Negativeℤ : Negative ℤ
  Negativeℤ = record
    { Constraint = λ n → ⊤
    ; fromNeg = λ n → negate (fromℕ n)
    }
